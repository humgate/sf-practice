# Резюме
Проект содержит выполнение задания 27.5.1 учебного курса Java разработчик SF
# Описание решения
1. Реализованы необходимые методы сортировки (класс `Sorters`). Для метода быстрой сортировки Хоера был 
   реализован дополнительный (оптимизированный) метод (класс `QuickSorters`).
   
2. Реализован класс `Benchmarks`для проведения сравнительного теста скорости работы методов сортировки. Для измерения
   времени работы сортировки использована генерация числа типа `long` с помощью `Systrem.nanoTime()` перед вызовом и 
   после вызова метода сортировки и последующим вычислением разницы между ними:
   ```
   long startTime = System.nanoTime();
   // вызов метода
   long endTime = System.nanoTime();
   long timeElapsed = endTime - startTime;
   ```
3. Выполнено несколько итераций тестов `Benchmarks.main()`для различных значений диапазона длинны массива n и шага 
   теста:
   ```
   a) 1 < n <= 4000 c шагом 1;
   б) 4K < n < 200К с шагом 10К;
   ```
   Для каждого значения n запускались последовательно все методы сортировки (из класса `Sorters`), замерялось и 
   записывалось в файл время работы каждого алгоритма при каждом `n`.
   
4. Результаты тестов в виде графиков собраны в [Google таблица](https://docs.google.com/spreadsheets/d/e/2PACX-1vTbTGCUdgaQP1U_A92-RL29sZGVRY-yySS8qIyKMJvlQp84WY6__dK5CaOO50EsK9MszuzQyKVdFgSl/pubhtml?gid=613902995&single=true "Графики")
   
5. Выводы об эффективности алгоритмов:
   ```
   при 1 < n <= 21 - selection sort
   при 21 < n <= 145 - merge sort
   при 145 < n <= 450 - selection sort (как это не странно, но несколько раз повторял тесты и именно так выходит)
   при 450 < n < 200 000 - merge Sort (при более высоких значениях не тестировалось)
   ```
6. Код единого алгоритма, выполняющего комбинированную сортировку с вызовом разных методов в зависимости от 
   входного `n` реализован в методе `combinedSort(int[] arr)` класса `CombinedSorters`
   
