# Резюме
Проект содержит выполнение заданий по следующим учебным модулям курса SF "Java разработчик":
1. Задание 27.5.1; 
2. Задание 28.6.1.

Решение каждого из заданий оформлено в виде набора классов в отдельном пакете репозитория. Ниже для решения каждого 
задания представлено описание, в т.ч. с указанием имени пакета содержащего решение.

# Задание 27.5.1.
Формулировка задания: Известно, что сортировки, работающие за асимптотическое время O(n),
часто скрывают в асимптотике константу, из-за которой при малых n они могут проигрывать по времени квадратичным
сортировкам. Ваша задача — используя написанные вами ранее реализации сортировок вставками, пузырьком, merge и
quick, провести замеры времени их работы для разных n и собрать единый метод, динамически выбирающий разные
алгоритмы сортировки для разных n.
### Описание решения
##### Решение оформлено в пакете sorters.
1. Реализованы необходимые методы сортировки (класс `sorters.Sorters`). Для метода быстрой сортировки Хоера был 
   реализован дополнительный (оптимизированный) метод (класс `sorters.QuickSorters`).
   
2. Реализован класс `Benchmarks`для проведения сравнительного теста скорости работы методов сортировки. Для измерения
   времени работы сортировки использована генерация числа типа `long` с помощью `Systrem.nanoTime()` перед вызовом и 
   после вызова метода сортировки и последующим вычислением разницы между ними:
   ```
   long startTime = System.nanoTime();
   // вызов метода
   long endTime = System.nanoTime();
   long timeElapsed = endTime - startTime;
   ```
3. Выполнено несколько итераций тестов `sorters.Benchmarks.main()`для различных значений диапазона длинны массива n и
   шага теста:
   ```
   a) 1 < n <= 4000 c шагом 1;
   б) 4K < n < 200К с шагом 10К;
   ```
   Для каждого значения n запускались последовательно все методы сортировки (из класса `sorters.Sorters`), замерялось и 
   записывалось в файл время работы каждого алгоритма при каждом `n`.
   
4. Результаты тестов в виде графиков собраны в [Google таблица](https://docs.google.com/spreadsheets/d/e/2PACX-1vTbTGCUdgaQP1U_A92-RL29sZGVRY-yySS8qIyKMJvlQp84WY6__dK5CaOO50EsK9MszuzQyKVdFgSl/pubhtml?gid=613902995&single=true "Графики")
   
5. Выводы об эффективности алгоритмов:
   ```
   при 1 < n <= 21 - selection sort
   при 21 < n <= 145 - merge sort
   при 145 < n <= 450 - selection sort (как это не странно, но несколько раз повторял тесты и именно так выходит)
   при 450 < n < 200 000 - merge Sort (при более высоких значениях не тестировалось)
   ```
6. Код единого алгоритма, выполняющего комбинированную сортировку с вызовом разных методов в зависимости от 
   входного `n` реализован в методе `combinedSort(int[] arr)` класса `sorters.CombinedSorters`

# Задание 28.6.1.
Формулировка задания: Ваша задача — найти коммит, в котором в репозиторий интерпретатора CPython был добавлен модуль 
для бинарного поиска (bisect). Для этого предлагается реализовать собственный упрощённый аналог git bisect.
Ваша программа получает список коммитов начиная с 7f777ed95a19224294949e1b4ce56bbffcb1fe9f и заканчивая
7f777ed95a19224294949e1b4ce56bbffcb1fe9f вызовом команды 
```
git rev-list --ancestry-path <last-commit-in-old-state> <first-commit-in-new-state>
```
Далее, ваша программа выполняет бинарный поиск по этому списку. Её задача — найти самый ранний коммит, в котором 
<command ...> завершается с exit code 1. Для этого на каждый коммит-кандидат она сначала вызывает git checkout <commit>,
а потом запускает и проверяет код возврата. Программа печатает хэш этого коммита и завершается.
### Описание решения
##### Решение оформлено в пакете bisect.
1. Класс `bisect.Command` реализует команду проверки наличия в рабочей локально рабочей директории git файла 
   Lib/bisect.py. Для более удобного ее вызова она помещена в файл command.bat.
2. Класс `bisect.Utils` реализует методы запуска внешней программы и чтения ее вывода и чтения ее кода завершения
3. Класс `bisect.GitBisect` реализует метод бинарного поиска и сам метод main принимающий три аргумента: хэш первого 
   коммита, хэш последнего коммита, имя команды
4. Бинарный поиск с указанными границами проводит 11 итераций и находит коммит с порядковым номер 177 
   (считая от самого позднего к первому) и хэшэм:
   `4e16098ce74c645cf1d69566b6f8bc96031554b7`
5. Для проверки правильности нахождения коммита можно использовать команду 
   ```
   $ git blame Lib/bisect.py
   ```
   которая выводит все коммиты, в которых происходили какие-либо изменения с файлом Lib/bisect.py. И первой самой
   ранней строкой выводится информация как раз по коммиту `4e16098ce74c645cf1d69566b6f8bc96031554b7`